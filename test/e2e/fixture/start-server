#!/bin/bash
# Start the moltworker for E2E testing

set -e

VERBOSE=false
if [ "$1" = "-v" ] || [ "$1" = "--verbose" ]; then
    VERBOSE=true
fi

log() {
    if [ "$VERBOSE" = true ]; then
        echo "[start-server] $*" >&2
    fi
}

# Support running directly (not via cctr) for manual debugging
if [ -z "$CCTR_TEST_PATH" ]; then
    SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
    CCTR_TEST_PATH="$(dirname "$SCRIPT_DIR")"
    log "CCTR_TEST_PATH not set, using: $CCTR_TEST_PATH"
fi
if [ -z "$CCTR_FIXTURE_DIR" ]; then
    CCTR_FIXTURE_DIR="/tmp/e2e-manual"
    mkdir -p "$CCTR_FIXTURE_DIR"
    log "CCTR_FIXTURE_DIR not set, using: $CCTR_FIXTURE_DIR"
fi

PROJECT_DIR="$(cd "$CCTR_TEST_PATH/../.." && pwd)"
PORT=8686
GATEWAY_TOKEN="e2e-test-token-1234567890"

log "Project directory: $PROJECT_DIR"
log "Fixture directory: $CCTR_FIXTURE_DIR"
log "Port: $PORT"
log "Gateway token: $GATEWAY_TOKEN"

# Kill any existing server on our port
log "Killing any existing server on port $PORT..."
pkill -f "wrangler.*--port.*$PORT" 2>/dev/null || true
pkill -f "wrangler dev" 2>/dev/null || true
sleep 0.5

# Stop any existing sandbox containers
log "Stopping any existing sandbox containers..."
docker ps -q --filter "name=workerd-moltbot-sandbox" 2>/dev/null | xargs -r docker stop 2>/dev/null || true
docker ps -aq --filter "name=workerd-moltbot-sandbox" 2>/dev/null | xargs -r docker rm 2>/dev/null || true

cd "$PROJECT_DIR"

# Install dependencies if needed
if [ ! -d node_modules ]; then
    log "Installing dependencies..."
    npm install --silent 2>/dev/null
fi

# Build the project (required after code changes)
log "Building project..."
if [ "$VERBOSE" = true ]; then
    npm run build >&2
else
    npm run build >/dev/null 2>&1
fi

# Write token to a file so tests can read it
echo "$GATEWAY_TOKEN" > "$CCTR_FIXTURE_DIR/gateway-token.txt"

# Generate complete .dev.vars.e2e by copying from .dev.vars and overriding what we need
log "Creating .dev.vars.e2e..."
cat > "$CCTR_FIXTURE_DIR/.dev.vars.e2e" << EOF
E2E_TEST_MODE=true
DEBUG_ROUTES=true
MOLTBOT_GATEWAY_TOKEN=$GATEWAY_TOKEN
EOF

# Copy all other settings from existing .dev.vars (except the ones we override)
if [ -f "$PROJECT_DIR/.dev.vars" ]; then
    log "Copying settings from .dev.vars..."
    grep -v -E "^(E2E_TEST_MODE|DEV_MODE|DEBUG_ROUTES|MOLTBOT_GATEWAY_TOKEN)=" "$PROJECT_DIR/.dev.vars" >> "$CCTR_FIXTURE_DIR/.dev.vars.e2e" 2>/dev/null || true
fi

# Also pick up API keys and channel tokens from environment (for CI)
for var in AI_GATEWAY_API_KEY AI_GATEWAY_BASE_URL ANTHROPIC_API_KEY OPENAI_API_KEY \
           TELEGRAM_BOT_TOKEN TELEGRAM_DM_POLICY TELEGRAM_DM_ALLOW_FROM \
           DISCORD_BOT_TOKEN DISCORD_DM_POLICY \
           SLACK_BOT_TOKEN SLACK_APP_TOKEN; do
    if [ -n "${!var}" ]; then
        echo "$var=${!var}" >> "$CCTR_FIXTURE_DIR/.dev.vars.e2e"
    fi
done

if [ "$VERBOSE" = true ]; then
    log "Generated .dev.vars.e2e contents:"
    cat "$CCTR_FIXTURE_DIR/.dev.vars.e2e" >&2
fi

# Temporarily rename .dev.vars so wrangler ONLY reads our test config
if [ -f "$PROJECT_DIR/.dev.vars" ]; then
    log "Temporarily moving .dev.vars out of the way..."
    mv "$PROJECT_DIR/.dev.vars" "$PROJECT_DIR/.dev.vars.e2e-backup"
fi

# Copy our test config to .dev.vars location so wrangler finds it
cp "$CCTR_FIXTURE_DIR/.dev.vars.e2e" "$PROJECT_DIR/.dev.vars"

log "Starting wrangler dev..."
# Start wrangler in background, logging to file
# Use nohup and redirect all output to detach from terminal
nohup npx wrangler dev \
    --port "$PORT" \
    > "$CCTR_FIXTURE_DIR/wrangler.log" 2>&1 &
WRANGLER_PID=$!
echo $WRANGLER_PID > "$CCTR_FIXTURE_DIR/wrangler.pid"
log "Wrangler PID: $WRANGLER_PID"

# In verbose mode, tail the log in background so we can see output
if [ "$VERBOSE" = true ]; then
    tail -f "$CCTR_FIXTURE_DIR/wrangler.log" >&2 &
    TAIL_PID=$!
fi

# Give wrangler a moment to read the config, then restore original .dev.vars
sleep 2
if [ -f "$PROJECT_DIR/.dev.vars.e2e-backup" ]; then
    log "Restoring original .dev.vars..."
    mv "$PROJECT_DIR/.dev.vars.e2e-backup" "$PROJECT_DIR/.dev.vars"
fi

# Wait for server to be ready (container startup can take 1-2 minutes)
log "Waiting for server to be ready..."
consecutive_503=0
TIMEOUT_SECONDS=180
START_TIME=$(date +%s)
while true; do
    ELAPSED=$(($(date +%s) - START_TIME))
    if [ "$ELAPSED" -ge "$TIMEOUT_SECONDS" ]; then
        log "Timeout waiting for server after ${ELAPSED}s"
        [ -n "$TAIL_PID" ] && kill $TAIL_PID 2>/dev/null || true
        cat "$CCTR_FIXTURE_DIR/wrangler.log" >&2
        exit 1
    fi

    # Check for 200 response, not just any response
    status=$(curl -s -o /dev/null -w "%{http_code}" "http://localhost:$PORT/?token=$GATEWAY_TOKEN" 2>/dev/null || echo "000")
    if [ "$status" = "200" ]; then
        log "Server is ready! (HTTP $status after ${ELAPSED}s)"
        log "Open: http://localhost:$PORT/?token=$GATEWAY_TOKEN"
        # Kill the tail process if running
        [ -n "$TAIL_PID" ] && kill $TAIL_PID 2>/dev/null || true
        # Small delay to let stderr flush before stdout
        sleep 0.1
        echo "ready"
        exit 0
    fi
    
    # Track consecutive 503 errors - these indicate the gateway is failing repeatedly
    if [ "$status" = "503" ]; then
        consecutive_503=$((consecutive_503 + 1))
        # After 3 consecutive 503s, check for fatal errors in the log
        if [ "$consecutive_503" -ge 3 ]; then
            if grep -q "Config invalid" "$CCTR_FIXTURE_DIR/wrangler.log" 2>/dev/null; then
                log "Fatal error: Gateway config is invalid"
                [ -n "$TAIL_PID" ] && kill $TAIL_PID 2>/dev/null || true
                echo "ERROR: Gateway failed to start due to invalid config:" >&2
                grep -A5 "Config invalid" "$CCTR_FIXTURE_DIR/wrangler.log" | head -20 >&2
                exit 1
            fi
        fi
    else
        consecutive_503=0
    fi
    
    if [ "$VERBOSE" = true ] && [ $((ELAPSED % 10)) -lt 2 ]; then
        log "Still waiting... (${ELAPSED}s elapsed, last status: $status)"
    fi
    sleep 1
done
